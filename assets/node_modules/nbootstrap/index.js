import { bootstrapClient, BlobStoreClient } from './pb/bootstrap_pb_service.js'
import { BlobBody, RuntimeInfo, PingRequest, LaunchInfo, Config } from './pb/bootstrap_pb.js'
import { ForceInstall } from './install'

import { grpc } from "@improbable-eng/grpc-web";
const ws = grpc.WebsocketTransport()

function urlJoin(origin, path) {
  return origin.replace(/\/$/, "") +
    "/" +
    path.replace(/^\//, "")
}


export let BootstrapVersion = `${Config.BOOTSTRAPVERSION}`


export class NBootstrap {
  constructor(address=`http://127.0.0.1:${Config.TCPPORT}`) {
    this._address_ = address
    this._bootstrap_ = new bootstrapClient(address)
    this._blobstore_ = new BlobStoreClient(address)
  }

  async WhetherInstalled() {
    return new Promise((resolve, reject) => {
     this._bootstrap_.ping(new PingRequest(), (err, msg) => {
        if (err) {
	  resolve(false)
        } else {
	  resolve(msg)
        }
      })
    })
  }

  async UploadFile(md5sum, url, max_retry, progressFN) {
    if (typeof progressFN !== "function") {
      progressFN = function(fileMD5, size) {
        console.log(`File Md5: ${fileMD5}, already upload data size: ${size}`)
      }
    }
    let r = await this.UploadBlob(md5sum, fetch(url), progressFN)
    for (let i=0; i<max_retry; i++) {
      if (r.done) {
	return r
      }
      console.log(`Upload ${md5sum} failed ${JSON.stringify(r)}. It will retry after waiting 2s.`)
      await new Promise(r => setTimeout(r, 2000));
      r = await this.UploadBlob(md5sum, fetch(url), progressFN)
    }
    throw(`Upload ${md5sum} failed after ${max_retry} times`);
  }
  async UploadBlob(md5sum, fetch_body, progressFN) {
    let old = this._blobstore_.options.transport;
    this._blobstore_.options.transport = ws;
    let client = this._blobstore_.upload();
    this._blobstore_.options.transport = old;
    this._blobstore_.options.debug = true;

    return new Promise(async (resolve, reject) => {
      try {
        let done = false;
	client.on("data", (d) => {
	  done = true;
	  resolve(d.toObject())
	})
        client.on("end", (status, ss) => {
          done = true;
          if (status.code != 0) {
            reject(status)
          }
        })

	let blk = new BlobBody()
	blk.setFileMd5Hash(md5sum)
	//第一个数据块必须只包含file_hash不包含任何实际数据
	client.write(blk)

        let resp = await fetch_body
        if (resp.ok !== true) {
          reject(resp.statusText);
          return;
        }

	await new Promise(r => setTimeout(r, 300));

        let charsSended = 0
        const reader = resp.body.getReader();
        let upload = (blk) => {
          if (done) {
            return
          }
	  if (blk.done) {
	    client.end()
	  } else {
            let msg = new BlobBody
	    msg.setData(blk.value)

	    client.write(msg)
            charsSended += blk.value.length
            progressFN(md5sum, charsSended)

            setTimeout(()=>{
              reader.read().then(upload)
            }, 1)
          }
        }
        reader.read().then(upload).catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  }

  async LaunchProxy(programs, progressFN) {
    let pingMsg = await this.WhetherInstalled()
    if (!pingMsg) {
      ForceInstall(this.WhetherInstalled.bind(this), programs)
      throw("Current page is waiting for installing nanoapp.bootstrap")
    }
    // this.dumpInfo(pingMsg)

    let sinfo = new LaunchInfo()
    let p = sinfo.getProgramsMap()

    let platform = pingMsg.getPlatform()
    let progInfo = programs[platform];
    if (!progInfo) {
      throw(`Can't find nproxy information for platform ${platform}`)
    }

    let i = new LaunchInfo.Program()
    i.setHash(progInfo.hash)
    i.setSign(progInfo.sign)
    p.set(platform, i)

    //注册此proxy的服务

    let registerNProxyFn = () => {
      return new Promise((resolve, reject) => {
	this._bootstrap_.launchProxy(sinfo, (err, msg) => {
          if (err) {
	    reject(err)
          } else {
            resolve(msg)
          }
	})
      })
    }

    try {
      return await registerNProxyFn();
    } catch (err) {
      const errorNeedUpload = "You Need upload NProxy before using"
      if (err.message == errorNeedUpload) {
	await this.UploadFile(progInfo.hash, urlJoin(location.origin, progInfo.path), 20, progressFN);
	return registerNProxyFn()
      }
    }
  }

  dumpInfo(pingMsg) {
    function capsule(title, info) {
      console.log(
        `%c ${title} %c ${info} %c`,
        'background:#35495E; padding: 1px; border-radius: 3px 0 0 3px; color: #fff;',
        `background:#3488ff; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff;`,
        'background:transparent'
      )
    }
    capsule(`The nbootstrap platform(${this._address_}): `, `${pingMsg.getPlatform()}`)
    capsule(`The nbootstrap version(${this._address_}): `, `${pingMsg.getVersion()}`)
  }
}
